digraph {
method -> methodDeclaration;
methodDeclaration -> keywordMethod;
keywordMethod -> keyword;
keyword -> identifier;
identifier -> UNDERSCORE_ALPHA;
UNDERSCORE_ALPHA -> ALPHA;
identifier -> UNDERSCORE_ALPHANUMERIC;
UNDERSCORE_ALPHANUMERIC -> UNDERSCORE_ALPHA;
UNDERSCORE_ALPHANUMERIC -> DIGIT;
keyword -> COLON;
keywordMethod -> variable;
variable -> identifier;
methodDeclaration -> unaryMethod;
unaryMethod -> identifier;
methodDeclaration -> binaryMethod;
binaryMethod -> binary;
binary -> BINARYSYMBOL;
binaryMethod -> variable;
method -> methodSequence;
methodSequence -> PERIOD;
methodSequence -> pragmas;
pragmas -> pragma;
pragma -> LT;
pragma -> pragmaMessage;
pragmaMessage -> keywordPragma;
keywordPragma -> keyword;
keywordPragma -> arrayItem;
arrayItem -> literal;
literal -> numberLiteral;
numberLiteral -> DIGITS;
DIGITS -> DIGIT;
numberLiteral -> RADIX;
numberLiteral -> MINUS;
numberLiteral -> PERIOD;
numberLiteral -> EXP;
literal -> stringLiteral;
stringLiteral -> QUOTE;
literal -> charLiteral;
charLiteral -> DOLAR;
literal -> arrayLiteral;
arrayLiteral -> BEGIN_ARRAY;
BEGIN_ARRAY -> HASH;
BEGIN_ARRAY -> LPAREN;
arrayLiteral -> arrayItem;
arrayLiteral -> RPAREN;
literal -> byteLiteral;
byteLiteral -> BEGIN_BIN_ARRAY;
BEGIN_BIN_ARRAY -> HASH;
BEGIN_BIN_ARRAY -> LPAREN;
byteLiteral -> numberLiteral;
byteLiteral -> RBRACKET;
literal -> symbolLiteral;
symbolLiteral -> HASH;
symbolLiteral -> symbol;
symbol -> unary;
unary -> identifier;
unary -> COLON;
symbol -> binary;
symbol -> multiword;
multiword -> keyword;
symbol -> stringLiteral;
literal -> NIL;
literal -> TRUE;
literal -> FALSE;
arrayItem -> symbolLiteralArray;
symbolLiteralArray -> symbol;
arrayItem -> arrayLiteralArray;
arrayLiteralArray -> RPAREN;
arrayLiteralArray -> arrayItem;
arrayItem -> byteLiteralArray;
byteLiteralArray -> LBRACKET;
byteLiteralArray -> arrayItem;
byteLiteralArray -> RBRACKET;
pragmaMessage -> unaryPragma;
unaryPragma -> identifier;
pragmaMessage -> binaryPragma;
binaryPragma -> binary;
binaryPragma -> arrayItem;
pragma -> GT;
methodSequence -> temporaries;
temporaries -> PIPE;
temporaries -> variable;
methodSequence -> statements;
statements -> expression;
expression -> assignment;
assignment -> variable;
assignment -> ASSIGN;
expression -> cascadeExpression;
cascadeExpression -> keywordExpression;
keywordExpression -> binaryExpression;
binaryExpression -> unaryExpression;
unaryExpression -> primary;
primary -> literal;
primary -> variable;
primary -> block;
block -> LBRACKET;
block -> blockBody;
blockBody -> blockArguments;
blockArguments -> blockArgument;
blockArgument -> COLON;
blockArgument -> variable;
blockArguments -> PIPE;
blockBody -> sequence;
sequence -> temporaries;
sequence -> PERIOD;
sequence -> statements;
block -> RBRACKET;
primary -> parens;
parens -> LPAREN;
parens -> expression;
parens -> RPAREN;
primary -> array;
array -> LCURLY;
array -> expression;
array -> PERIOD;
array -> RCURLY;
unaryExpression -> unaryMessage;
unaryMessage -> unary;
binaryExpression -> binaryMessage;
binaryMessage -> binary;
binaryMessage -> unaryExpression;
keywordExpression -> keywordMessage;
keywordMessage -> keyword;
keywordMessage -> binaryExpression;
cascadeExpression -> cascadeMessage;
cascadeMessage -> SEMICOLON;
cascadeMessage -> message;
message -> keywordMessage;
message -> binaryMessage;
message -> unaryMessage;
statements -> PERIOD;
statements -> statements;
statements -> return;
return -> RETURN;
return -> expression;
}